---
doc_type: weread-highlights-reviews
bookId: "30179184"
author: 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔
cover: https://weread-1258476243.file.myqcloud.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg
reviewCount: 3
noteCount: 27
name: 操作系统导论
tags: weread
isbn: 9787115508232
rating: null
banner: "![[true.jpg]]"
publish: 人民邮电出版社
publishyear: 2019-06-01
category: 计算机-计算机综合
grade: null
status: null
readtime: null
pagecount: null
pageprogress: null
---

## 操作系统导论

> [!bookinfo]+ **《操作系统导论》**
> ![bookcover|200](https://weread-1258476243.file.myqcloud.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg)
>
| 属性   | 内容                                       |
|- | - | - |
| ISBN   | 9787115508232  |
| 作者   | 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔                         |
| 出版年 | 2019-06-01   | 
| 出版社 | 人民邮电出版社                       |
| 来源   | [操作系统导论](https://weread.qq.com/web/) |
| 分类   | 计算机-计算机综合                        |

> [!abstract]- **内容简介**
> 
> 《操作系统导论》
> 这是一本关于现代操作系统的书。全书围绕虚拟化、并发和持久性这3个主要概念展开，介绍了所有现代系统的主要组件（包括调度、虚拟内存管理、磁盘和I/O子系统、文件系统 ）。 本书共50章，分为3个部分，分别讲述虚拟化、并发和持久性的相关内容。本书大部分章节均先提出特定的问题，然后通过书中介绍的技术、算法和思想来解决这些问题。笔者以对话形式引入所介绍的主题概念，行文诙谐幽默却又鞭辟入里，力求帮助读者理解操作系统中虚拟化、并发和持久性的原理。 本书内容全面，并给出了真实可运行的代码（而非伪代码），还提供了相应的练习，适合高等院校相关专业教师教学和高校学生自学。

## 高亮划线
### 第2章 操作系统介绍

> [!quote|notitle] 
> 一次运行多个程序的能力会引发各种新问题  
— 创建于 [[2021-11-26]] 15:10 ^9-3840-3859

> [!quote|notitle] 
> 程序的每个指令都在内存中  
— 创建于 [[2021-11-26]] 15:34 ^9-4339-4351

> [!quote|notitle] 
> 这正是操作系统虚拟化内存（virtualizing memory）时发生的情况。每个进程访问自己的私有虚拟地址空间（virtual address space）  
— 创建于 [[2021-11-26]] 15:51 ^9-6006-6086

> [!quote|notitle] 
> 操作系统以某种方式映射到机器的物理内存上  
— 创建于 [[2021-11-26]] 15:52 ^9-6111-6131

> [!quote|notitle] 
> 这些问题在同时（并发地）处理很多事情时出现且必须解决  
— 创建于 [[2021-11-26]] 15:53 ^9-6385-6411

> [!quote|notitle] 
> 将线程看作与其他函数在同一内存空间中运行的函数，并且每次都有多个线程处于活动状态  
— 创建于 [[2021-11-26]] 18:41 ^9-7676-7716

> [!quote|notitle] 
> 原子方式  
— 创建于 [[2021-11-26]] 18:57 ^9-8836-8840

> [!quote|notitle] 
> 系统调用将控制转移（跳转）到OS中，同时提高硬件特权级别  
— 创建于 [[2021-11-26]] 23:08 ^9-14047-14075

> [!quote|notitle] 
> 用户应用程序以所谓的用户模式（user mode）运行，这意味着硬件限制了应用程序的功能  
— 创建于 [[2021-11-26]] 23:08 ^9-14102-14146

> [!quote|notitle] 
> 操作系统不是一次只运行一项作业，而是将大量作业加载到内存中并在它们之间快速切换，从而提高CPU利用率  
— 创建于 [[2021-11-26]] 23:10 ^9-14765-14815

> [!quote|notitle] 
> I/O设备很慢。在处理I/O时让程序占着CPU，浪费了CPU时间  
— 创建于 [[2021-11-26]] 23:11 ^9-14827-14859

> [!quote|notitle] 
> 内存保护（memory protection  
— 创建于 [[2021-11-26]] 23:11 ^9-14948-14970
### 第4章 抽象：进程

> [!quote|notitle] 
> 进程的非正式定义非常简单：进程就是运行中的程序  
— 创建于 [[2021-11-26]] 23:24 ^11-394-417

> [!quote|notitle] 
> 程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来  
— 创建于 [[2021-11-26]] 23:24 ^11-418-472

> [!quote|notitle] 
> 潜在的开销就是性能损失，因为如果CPU必须共享，每个进程的运行就会慢一点  
— 创建于 [[2021-11-26]] 23:27 ^11-911-947

> [!quote|notitle] 
> 指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分  
— 创建于 [[2021-11-26]] 23:31 ^11-1974-2044
> [!quote|notitle] 
> 仅在程序执行期间需要加载的代码或数据片段，才会加载  
— 创建于 [[2021-11-26]] 23:36 ^11-4087-4112
- 前端优化也借鉴了该想法，当前页面需要的的代码才会被请求以及加载

> [!quote|notitle] 
> 分页和交换的机制  
— 创建于 [[2021-12-01]] 17:08 ^11-4142-4150

> [!quote|notitle] 
> 操作系统在运行此进程之前  
— 创建于 [[2021-12-01]] 17:14 ^11-4249-4261

> [!quote|notitle] 
> 必须为程序的运行时栈（run-time stack或stack）分配一些内存  
— 创建于 [[2021-12-01]] 17:14 ^11-4273-4311
> [!quote|notitle] 
> 操作系统也可能为程序的堆（heap）分配一些内存  
— 创建于 [[2021-12-01]] 17:14 ^11-4424-4448
- 操作系统运行程序之前会分配栈内存以及堆内存

> [!quote|notitle] 
> 通过跳转到main()例程  
— 创建于 [[2021-12-02]] 09:24 ^11-4903-4916

> [!quote|notitle] 
> OS将CPU的控制权转移到新创建的进程中，从而程序开始执行  
— 创建于 [[2021-12-02]] 09:24 ^11-4929-4958

> [!quote|notitle] 
> 进程。它很简单地被视为一个正在运行的程序  
— 创建于 [[2021-12-02]] 09:43 ^11-9576-9596
### 第5章 插叙：进程API

> [!quote|notitle] 
> 进程调用了fork()系统调用，这是操作系统提供的创建新进程的方法  
— 创建于 [[2021-12-02]] 18:43 ^12-2171-2204

> [!quote|notitle] 
> 调用fork()，这只是在你想运行相同程序的拷贝时有用  
— 创建于 [[2021-12-03]] 13:12 ^12-4849-4876

> [!quote|notitle] 
> 因此，它并没有创建新进程，而是直接将当前运行的程序（以前的p3）替换为不同的运行程序（wc）  
— 创建于 [[2021-12-03]] 13:16 ^12-6564-6610

> [!quote|notitle] 
> 操作系统也可能为程序的堆（heap）分配一些内存 
— 创建于 [[2021-12-01]] 17:15 ^39424877-7ve4vCqNE
- 操作系统运行程序之前会分配栈内存以及堆内存> [!quote|notitle] 
> 仅在程序执行期间需要加载的代码或数据片段，才会加载 
— 创建于 [[2021-12-01]] 17:08 ^39424877-7ve441iT6
- 前端优化也借鉴了该想法，当前页面需要的的代码才会被请求以及加载> [!quote|notitle] 
> 时间片 
— 创建于 [[2021-11-26]] 23:25 ^39424877-7v6RdVlK4
- 千分之一秒？ 


